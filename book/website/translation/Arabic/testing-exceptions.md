(اختبار - تحديات)=
# التحديات والحالات الاستثنائية في الاختبار

(r-testting-challenges es-stochastic-code)=
## اختبار الرمز البلاستيكي

في بعض الأحيان تحتوي التعليمات البرمجية على عنصر عشوائي، مثال شائع على التعليمات البرمجية التي تستخدم [طرق مونت كارلو](https://en.wikipedia.org/wiki/Monte_Carlo_method). اختبار هذا النوع من التعليمات البرمجية قد يكون صعباً جداً لأنه إذا تم تشغيله عدة مرات فإنه سيولد إجابات مختلفة، كل ما قد يكون "صحيحاً"، حتى أنه لا يحتوي على أي أخطاء. وهناك طريقتان رئيسيتان لمعالجة اختبار شفرة البلاستيك:

### استخدام بذور أرقام عشوائية

أعداد عشوائية من البذور يصعب تفسيرها قليلاً لذلك هنا مثال. إليك نص بايثون صغير يطبع ثلاثة أرقام عشوائية.

```python
استيراد عشوائي

# طباعة ثلاثة أرقام عشوائية
print(random.random())
print(random.random())
print(random.random())
```

هذا البرنامج النصي لا يحتوي على أي أخطاء ولكن إذا قمت بتشغيله بشكل متكرر، فستحصل على إجابات مختلفة في كل مرة. الآن دعونا نعيّن رقم عشوائي.

```python
استيراد عشوائي

# تعيين رقم عشوائي
عشوائي.seed(1)

# طباعة ثلاثة أرقام عشوائية
طبعة (random.random())
print(random.random())
print(random.random())
```

الآن إذا قمت بتشغيل هذا البرنامج النصي فإنه يخرجه

```python

0.134364244112 
 0.847433736937
0.763774618977
```

وفي كل مرة تقوم بتشغيل هذا البرنامج النصي ستحصل على *نفس* الإخراج، سيطبع *نفس* ثلاثة أرقام عشوائية. إذا تم تغيير رقم البذور العشوائي ستحصل على ثلاثة أرقام عشوائية مختلفة:

```python
0.956034271889
0.947827487059
0.0565513677268
```
ولكن مرة أخرى ستحصل على نفس الأرقام في كل مرة يتم تشغيل البرنامج النصي في المستقبل.

البذور العشوائية هي طريقة لجعل الأشياء عشوائية بشكل موثوق. غير أن خطر الاختبارات التي تعتمد على أعداد عشوائية هو أنها يمكن أن تكون حبيسة. قل أن لديك دالة منظمة مثل هذا:

```python
def my_function():
  a = calculation_that_uses_two_random_numbers()
  b = calculation_that_uses_five_random_numbers()
  c = a + b
```

إذا قمت بتعيين رقم عشوائي للبذور سوف تحصل دائما على نفس القيمة من `c`، بحيث يمكن اختبارها. لكن، قل أن النموذج قد تغير والدالة التي تحسب `A` تستخدم عددا مختلفا من الأرقام العشوائية التي قامت بها من قبل. الآن لن يكون `` مختلفا فقط ولكن `ب` سيكون أيضا لأنه كما هو موضح أعلاه الأعداد العشوائية التي يتم إخراجها بسبب رقم عشوائي هي بترتيب ثابت. ونتيجة لذلك، فإن الأرقام العشوائية المنتجة لحساب `b` ستكون قد تغيرت. وهذا يمكن أن يؤدي إلى فشل الاختبارات عندما لا يكون هناك في الواقع أي خطأ.

#### قياس توزيع النتائج

طريقة أخرى لاختبار التعليمات البرمجية مع مخرجات عشوائية هي تشغيلها مرات عديدة واختبار توزيع النتائج. ولعل النتيجة قد تتقلب قليلا، ولكن من المتوقع دائما أن تكون حوالي 10 في إطار قدر من التسامح. ويمكن اختبار ذلك. كلما زاد عدد المرات التي يتم فيها تشغيل التعليمات البرمجية كلما كان المتوسط أكثر موثوقية، وبالتالي كانت النتيجة. لكن، كلما قمت بتشغيل قطعة من التعليمات البرمجية كلما استغرق الأمر اختبارك فترة أطول، وهو ما قد يجعل إجراء الاختبارات يستغرق وقتاً طويلاً بدرجة تحول دون الحصول على نتيجة موثوقة. وعلاوة على ذلك، سيكون هناك دائما عنصر عدم يقين وإذا سقطت الأعداد العشوائية بطريقة معينة قد تحصل على نتيجة خارج نطاق التسامح المتوقع حتى لو كانت التعليمات البرمجية صحيحة.

وكلا هذين النهجين في اختبار الشفرة البلاستيكية يمكن أن يكونا مفيدين جدا، ولكن من المهم أيضا أن نكون على وعي بمخاطبهما المحتملة.

(r-test-challenges -difficult-quatify)=
## الاختبارات التي يصعب قياسها كمياً

في بعض الأحيان (ولا سيما في مجال البحث) يتم اختبار نواتج التعليمات البرمجية وفقاً لما إذا كانت "تنظر" صحيحة. على سبيل المثال ، لدينا رمز نمذجة لمستويات المياه في خزان مع مرور الوقت.

قد تبدو النتيجة هكذا:

```{figure} ../../figures/eyeball-test1.jpg
---
name: eyeball test1
alt:
---
```

في يوم واحد مع المطر قد يبدو هكذا:

```{figure} ../../figures/eyeball-test2.jpg
---
name: eyeball test2
alt:
---
```

وفي يوم جاف قد تبدو هكذا:

```{figure} ../../figures/eyeball-test3.jpg
---
الاسم: اختبار eyeball 3
البديل
---
```

وتبدو جميع هذه النواتج مختلفة جدا ولكنها صالحة. غير أنه إذا رأى أحد الباحثين نتيجة كهذه:

```{figure} ../../figures/eyeball-test-error.jpg
---
name: eyeball test-error
alt:
---
```

ويمكنها بسهولة أن تخلص إلى وجود خلل لأن من غير المرجح أن تزيد البحيرة حجمها ثلاث مرات ثم تفقدها مرة أخرى في غضون ساعات قليلة. اختبارات "العين" مثل هذه تستغرق وقتاً طويلاً كما يجب أن يقوم بها الإنسان. غير أن هذه العملية يمكن أن تكون آلية جزئيا أو كليا عن طريق إنشاء "فحوص عافية" أساسية. فعلى سبيل المثال، ينبغي أن يكون مستوى المياه في وقت ما في حدود 10 في المائة من مستوى المياه في الخطوة السابقة على سبيل المثال. ويمكن أن يكون التحقق الآخر أنه لا توجد قيم سلبية، حيث لا يمكن للبحيرة أن تكون ممتلئة بنسبة 30٪. هذا النوع من الاختبارات لا يمكن أن يغطي كل طريقة يمكن أن يكون فيها شيء خاطئا ظاهرا، ولكنها أسهل بكثير في التشغيل الآلي وستكفي في معظم الحالات.

(r-testting-challenges es-non-integer)=
## اختبار إذا كانت الأرقام غير الصحيحة متساوية

### عندما لا يساوي 0.1 + 0.2 0.3

هناك تعقيدات مع الاختبار إذا كانت الإجابة على جزء من مخرجات التعليمات البرمجية مساوية للإجابة المتوقعة عندما تكون الأرقام غير صحيحة. دعونا ننظر إلى مثال بايثون هذا، لكن نلاحظ أن هذه المشكلة لا تنفرد بها بايتون.

إذا قمنا بتعيين 0.1 إلى `A` و 0.2 إلى `b` وطباعة المبلغ الخاص بهم، نحصل على 0.3، كما هو متوقع.

```python
>>> a = 0.1
>>> b = 0.2
>>> print(+ b)
0.3
```

ولكن إذا قمنا بمقارنة نتيجة `` + `b` إلى 0.3 فإننا نحصل على خطأ ما.

```python
>>> print(+ b == 0.3)
False
```

إذا نظرنا إلى قيمة `` + `b` مباشرة، يمكننا أن نرى أن هناك هامش خطأ دقيق.

```python
>>> a + b
0.300000000000004
```

ويرجع ذلك إلى أن أرقام النقاط العائمة هي أرقام تقريبية للأرقام الحقيقية. ويمكن أن تعتمد نتيجة الحسابات بالنقاط العائمة على المترجم أو المترجم الشفوي أو المعالج أو بنية النظام وعدد وحدات المعالجة المركزية أو العمليات المستخدمة. ويمكن أن يشكل ذلك عقبة رئيسية أمام اختبارات الكتابة.

### المساواة في عالم ذي نقطة عائمة

وعند مقارنة أرقام النقاط العائمة للمساواة، علينا أن نقارنها في إطار تسامح معين، ويطلق عليها بدلا من ذلك عتبة أو دلتا على سبيل المثال وقد نعتبر أن القيم المحسوبة والمتوقعة لبعض الأعداد متساوية إذا كانت القيمة المطلقة لاختلافها في حدود القيمة المطلقة لتسامحنا.

ويوفر العديد من أطر الاختبار وظائف لمقارنة المساواة بين الأعداد ذات النقاط العائمة في إطار تسامح معين. وعلى سبيل المثال بالنسبة لاختبار الإطار:

```python
import pytest

a = 0.1
b = 0.2
c = a + b
assert c == pytest.approx(0.3)
```

هذا المرور ، ولكن إذا تم تغيير 0.3 إلى 0.4 ، فإن ذلك سيفشل.

وكثيرا ما توفر أطر اختبار الوحدات للغات الأخرى أيضا وظائف مماثلة:

- وحدة C: CU_ASSERT_DOUBLE_EQUAL(فعلي، متوقع، حبيبي)
- CPPUnit لـ C+++: CPPUNIT_ASSERT_DOUBLES_EQUAL(متوقع، فعلي، دلتا)
- اختبار جوجل لـ C++: ASSERT_NEAR(val1, val2, abs_error)
- FRUIT لـ Fortran: zt_eq_double_in_range_(var1, var2, delta, message)
- الوحدة المشتركة من أجل جافا: org.junit.Assert.assertEquals(كان متوقعا، فعلي مزدوج، دلتا مزدوجة)
- اختبار ل R:
  - expect_equal(فعلي, متوقع, التسامح =DELTA) - خطأ مطلق داخل DELTA
  - expect_equal(فعلي, متوقع, scale=توقع, tolerance=DELTA) - خطأ نسبي داخل DE L T A
