<a name="General_guidance_and_good_practice_for_testing"></a>

# الإرشادات العامة والممارسات الجيدة للاختبار

هناك عدة {ref}`أنواع مختلفة`<rr-testing-types-of-testing> • الاختبار الذي يكون لكل واحد منه أفضل الممارسات الخاصة به. ومع ذلك، هناك بعض الإرشادات العامة التي تنطبق على جميع هذه البلدان، والتي سيتم إيجازها هنا.

(ص - اختبار - كتابة)=
## كتابة الاختبارات - أي اختبارات!

بدء عملية اختبارات الكتابة يمكن أن يكون مغلقا، خاصة إذا كان لديك قاعدة رموز كبيرة. وعلاوة على ذلك، وكما ذكرنا فإن هناك أنواعا عديدة من الاختبارات، ويمكن أن يبدو تنفيذها جميعا كجبل مستحيل الصعود. ولهذا السبب فإن أهم توجيه في هذا الفصل هو كما يلي: **كتابة بعض الاختبارات**. اختبار شيء صغير في التعليمات البرمجية بطول آلاف الأسطر هو أفضل بلا حدود من اختبار لا شيء في التعليمات البرمجية التي تطول آلاف الأسطر. قد لا تكون قادراً على فعل كل شيء، ولكن القيام *بشيء* قيم.

إجراء تحسينات حيث يمكنك ذلك، وبذل قصارى جهدك لتضمين الاختبارات مع التعليمات البرمجية الجديدة التي تكتبها حتى لو لم يكن من الممكن كتابة الاختبارات لجميع التعليمات البرمجية المكتوبة بالفعل.

## تشغيل الاختبارات

ثاني أهم نصيحة في هذا الفصل: قم بتشغيل الاختبارات. إن وجود مجموعة اختبار جميلة مثالية لا يستخدم إذا كنت نادراً ما تشغلها. إن ترك فجوات طويلة بين عمليات الاختبار يزيد من صعوبة تتبع الخطأ الذي وقع عندما يفشل الاختبار، لأنه الكثير من التعليمات البرمجية ستكون قد تغيرت. وأيضا، إذا كان قد مضى أسابيع أو أشهر منذ إجراء الاختبارات وفشلت، ومن الصعب أو المستحيل معرفة ما هي النتائج التي تحققت في الوقت المتوسط التي لا تزال صالحة. والتي يجب أن تُلقى بعيداً لأنه كان يمكن أن تكون قد تأثرت بالخطأ.

من الأفضل أتمتة اختبارك قدر الإمكان. وإذا كان كل اختبار يحتاج إلى إجراء فردي، فمن المرجح أن تُهمل العملية المضنية المملة. يمكن القيام بذلك باستخدام إطار اختبار ([نوقش لاحقاً](#use-a-testing-framework)). [Jenkins](https://jenkins.io) أداة جيدة أخرى لهذا الغرض. قم بضبط اختباراتك بشكل مثالي لتعمل على فترات منتظمة، ربما كل ليلة.

النظر في إعداد التكامل المستمر (مناقشة في الفصل الخاص بالتكامل المستمر) في مشروعك. سيؤدي هذا تلقائياً إلى تشغيل الاختبارات الخاصة بك في كل مرة تقوم فيها بتغيير التعليمات البرمجية الخاصة بك، اعتمادًا على برنامج الدمج المستمر الذي تستخدمه، سيتم إعلامك إذا فشل أي من الاختبارات.

## فكر في الوقت الذي تستغرقه الاختبارات لتشغيلها

بعض الاختبارات، مثل {ref}`محرر الاختبار` فقط اختبار قطعة صغيرة من التعليمات البرمجية وبالتالي عادة ما تكون سريعة جدا. غير أن أنواعاً أخرى من الاختبارات، مثل {ref}`نظام اختبار rr-test-system` التي تختبر الكود بأكمله من النهاية إلى النهاية، قد يستغرق تشغيله وقتاً طويلاً اعتماداً على التعليمات البرمجية. وعلى هذا النحو، قد يكون من المعوق إجراء مجموعة الاختبار بأكملها بعد كل جزء صغير من العمل. وفي هذه الحالة، من الأفضل إجراء اختبارات أقل وزنا مثل اختبارات الوحدة بشكل متكرر، واختبارات أطول أجلا مرة واحدة في اليوم بين عشية وضحاها. من الجيد أيضاً قياس عدد كل نوع من الاختبارات التي لديك فيما يتعلق بمدة تشغيلها. يجب أن يكون لديك الكثير من اختبارات الوحدة (أو أنواع أخرى من الاختبارات السريعة) ولكن أقل بكثير من الاختبارات التي تستغرق وقتا طويلا للتشغيل.

## توثيق الاختبارات وكيفية تشغيلها

ومن المهم تقديم وثائق تصف كيفية إجراء الاختبارات، وكلاهما لنفسك في حالة عودتك إلى مشروع في المستقبل، ولأي شخص آخر يرغب في البناء على عملك أو استنساخه. وينبغي أن تشمل هذه الوثائق أيضاً مواضيع مثل

- أي موارد، مثل ملفات اختبار مجموعة البيانات المطلوبة
- أي تعديلات/إعدادات تحتاج لتشغيل الاختبارات
- ما هو البرنامج (مثل [أطر الاختبار](#use-a-testing-framework)) الذي يحتاج إلى تثبيته

من الناحية المثالية، يمكنك توفير البرامج النصية لإعداد وتكوين أي موارد مطلوبة.

## اختبار الحالات الواقعية

اجعل الحالات التي تختبرها واقعية قدر الإمكان. إذا على سبيل المثال، لديك بيانات غامضة لتشغيل الاختبارات عليك التأكد من أن البيانات مماثلة قدر الإمكان للبيانات الفعلية. إذا كانت بياناتك الفعلية فوضوية مع الكثير من القيم الفارغة، لذا يجب أن تكون مجموعة بيانات الاختبار الخاصة بك.

## استخدام إطار اختبار

وهناك أدوات متاحة لتيسير الكتابة وإجراء الاختبارات، وتعرف هذه الأدوات باسم أطر الاختبار. ابحث عن واحدة تحبها، اتعلم عن الميزات التي تعرضها، و استخدمها. وتشمل أطر الاختبار المشتركة (واللغات التي تنطبق عليها) ما يلي:

- لا تشرح اللغة
  - تم اختباره، اختبر الجهاز التنفيذي ، سكريبت باش ، وأكثر من ذلك. رائع لتحديث التعليمات البرمجية القديمة
- ++C
  - التقاط
  - اختبار كبست
  - التعزيز::اختبار
  - جوجل اختبار
- ج
  - جميع أطر C++
  - تحقق
  - CUnit
```{note}
في حين أن C++ و C الحديثين لا يزالان متوافقين في الأغلب، فإنهما لا يستعملان الإطار التجريبي بشكل متبادل، قد لا ينجحا دائما.
```
- Python
  - الاختبار (مستحسن)
  - unittest يأتي مع مكتبة بايثون القياسية
- اختبارات الوحدة R
  - اختبار
  - tinytest
  - SvUnit (يعمل مع SciViews GUI)
- اختبارات الوحدة الفورية:
  - وحدة
  - pfUnit (يعمل مع MPI)

## الهدف هو الحصول على تغطية رمزية جيدة

تغطية الكود هي مقياس لمقدار الكود الخاص بك "المشمول" بالتجارب. بمزيد من الدقة فإنه مقياس لكمية التعليمات البرمجية الخاصة بك التي يتم تشغيلها عند إجراء الاختبارات. لذا على سبيل المثال، إذا كان لديك بيان `إذا` ولكن فقط اختبر الأشياء التي يقوم فيها هذا البيان بتقييم "False" فلن يتم تشغيل أي من التعليمات البرمجية في الكتلة إذا تم تشغيل الكتلة. ونتيجة لذلك، ستكون تغطية التعليمات البرمجية الخاصة بك < 100%. التغطية البرمجية لا تشمل الوثائق مثل التعليقات، لذا فإن إضافة المزيد من الوثائق لا تؤثر على النسب المئوية.

وكما نوقش فإن أي اختبارات تمثل تحسنا عن عدم وجود اختبارات. ومع ذلك، من الجيد أن تطمح على الأقل إلى أن تكون تغطية التعليمات البرمجية الخاصة بك عالية قدر الإمكان.

ومعظم لغات البرمجة لديها أدوات إما مدمجة فيها، أو يمكن استيرادها، أو كجزء من أطر الاختبار، التي تقيس تلقائياً تغطية الرموز. هناك [بوت صغير لطيف](https://codecov.io/) لقياس تغطية التعليمات البرمجية المتاحة أيضا.

**Pitfall: وهم التغطية الجيدة.** في بعض الحالات، يمكن بل ربما ينبغي اختبار نفس الكود بطرق متعددة. على سبيل المثال، يمكن للتغطية أن تزيد بسرعة على التعليمات البرمجية التي تطبق اختبارات "التحقق من الصحة العامة" على إخراجها (انظر أيضا {ref}<rr-testing-challenges-difficult-quatify>)، ولكن هذا لا يستبعد احتمال أن تنتج التعليمات البرمجية الإجابة الصحيحة بشكل عام لأسباب خاطئة. وبوجه عام، فإن أفضل الاختبارات هي تلك التي تعزل الأجزاء الأصغر حجما بدلا من الأجزاء الأكبر من الشفرة المتسقة، وهكذا اختر خطوات فردية من المنطق. حاول أن تسترشد بالتفكير في الأشياء المحتملة التي قد تحدث لجزء معين من التعليمات البرمجية في تنفيذ الكل، واختبر هذه الحالات الفردية. في كثير من الأحيان، سيؤدي هذا إلى اختبار نفس الكود عدة مرات - هذا شيء جيد!

## استخدام اختبارات مضاعفة/مستودعات/سكاكين حيثما كان ذلك مناسباً

وفي حالة فشل الاختبار، ينبغي أن يوضع بحيث يكون من السهل تتبع مصدر الفشل قدر الإمكان. هذا يصبح مشكلة إذا كان جزء من التعليمات البرمجية تريد اختبارها يعتمد بشكل لا مفر منه على أشياء أخرى. على سبيل المثال إذا فشل اختبار لجزء من التعليمات البرمجية التي تتفاعل مع الويب، قد يكون ذلك لأن الكود يحتوي على خطأ *أو* بسبب وجود مشكلة في الاتصال بالإنترنت. وبالمثل، إذا فشل اختبار لجزء من التعليمات البرمجية التي تستخدم كائنا ما يمكن أن يكون بسبب وجود خلل في التعليمات البرمجية التي يجري اختبارها، أو مشكلة مع الجسم (الذي ينبغي اختباره بواسطة اختبارات منفصلة خاصة به). وينبغي إزالة هذه التبعيات من الاختبارات، إن أمكن. ويمكن القيام بذلك باستخدام بدائل الاختبار (مضاعفات الاختبار) بدلا من التبعيات الحقيقية. ويمكن تصنيف المزدوج الاختباري على النحو التالي:

- يتم تمرير جسم غريب ولكن لا يستخدم أبدا، مما يعني أن أساليبه لا تسمى مطلقا. ويمكن استخدام مثل هذا الجسم، على سبيل المثال، لملء قائمة البارامترات للطريقة.
- أشياء وهمية لها تطبيقات عمل، ولكن عادة ما تكون مبسطة. فهم، على سبيل المثال، يستخدمون قاعدة بيانات في الذاكرة وليس قاعدة بيانات حقيقية.
- المواد هي تنفيذ جزئي لواجهة أو فئة لغرض استخدام مثيل من هذه الأشياء أثناء الاختبار. عادة لا تستجيب الأستاذ لأي شيء خارج ما تم برمجته للاختبار. من الممكن أن تسجل الاستعلامات أيضاً معلومات عن المكالمات.
- الكائن الصوري هو التنفيذ الوهمي لواجهة أو فئة تحدد فيها ناتج مكالمات طريقة معينة. يتم تكوين الكائنات الوهمية لتنفيذ سلوك معين أثناء الاختبار. وعادة ما تسجل التفاعل مع النظام ويمكن للاختبارات أن تثبت صحة ذلك.

يمكن نقل مضاعفات الاختبار إلى الكائنات الأخرى التي يتم اختبارها.

يمكنك إنشاء كائنات وهمية يدوياً (عبر الكود) أو استخدام إطار صوري لمحاكاة هذه الصفوف الدراسية. تسمح لك الأطر الوهمية بإنشاء كائنات وهمية في وقت التشغيل وتحديد سلوكها. المثال الكلاسيكي لكائن صوري هو موفر البيانات. ويستخدم في إنتاج برنامج تنفيذي للاتصال بالمصدر الحقيقي للبيانات. ولكن لاختبار جسم صوري يحاكي مصدر البيانات ويكفل أن تكون ظروف الاختبار هي نفسها دائما.
