(r-test-unittest)=
# اختبار الوحدة

واختبارات الوحدات مسؤولة عن اختبار فرادى عناصر التعليمات البرمجية بطريقة معزولة ومحددة الأهداف بدرجة عالية. ويجري اختبار وظيفة كل وظيفة وفئة بمفردها على حدة. والغرض من ذلك هو التحقق من أن كل وحدة من وحدات البرمجيات تؤدي عملها على النحو المصمم. والوحدة هي أصغر جزء قابل للتزوير من أي برامج. وفي البرمجة الإجرائية، يمكن أن تكون الوحدة برنامجا فرديا أو وظيفة أو إجراء. وفي البرمجة الموجهة نحو الأهداف، عادة ما تكون أصغر وحدة أسلوبا. وعادة ما يكون لديها مدخل واحد أو بضعة مدخلات، وعادة ما يكون ناتجا واحدا. يجب استبدال أي تبعية خارجية بأشياء أو تطبيقات صورية لتركيز الاختبار كلياً على التعليمات البرمجية المعنية.

واختبارات الوحدات ضرورية لاختبار صحة عناصر الرموز الفردية من أجل الاتساق الداخلي والصحة قبل وضعها في سياقات أكثر تعقيدا. ومحدودية نطاق الاختبارات وإزالة التبعيات تجعل من الأسهل البحث عن سبب أي عيوب. كما أنه أفضل وقت لاختبار مجموعة متنوعة من المدخلات وفروع التعليمات البرمجية التي قد يكون من الصعب ضربتها في وقت لاحق. على سبيل المثال، كثيراً ما تستغرق اختبارات النظام وقتاً طويلاً لتشغيلها ومن المحتمل أن يكون من غير العملي إجراء اختبارات النظام لكل مسار ممكن من خلال شفرة تحتوي على أكثر من بضع عبارات مشروطة. واختبارات الوحدات أصغر حجما وأسرع، وبالتالي فإن من العملي أكثر تغطية جميع الحالات الممكنة معها.

وغالبا ما تكون اختبارات الوحدة، بعد إجراء أي اختبارات للدخان، هي أول اختبارات تجرى عند إجراء أي تغييرات.

## فوائد اختبار الوحدة

إذا قام أحد الباحثين بالتغيير إلى قطعة من التعليمات البرمجية أو كيفية تشغيلها، فكيف لهم أن يتأكدوا من أن القيام بذلك لم يكسر شيئاً؟ قد يجرون بعض الاختبارات، ولكن بدون اختبار كل قطعة صغيرة من التعليمات البرمجية بشكل فردي كيف يمكن التأكد منها؟ اختبار الوحدة يعطي الباحثين هذا اليقين، ويسمح لهم بالثقة عند تغيير التعليمات البرمجية الخاصة بهم والحفاظ عليها.

هذا مثال بسيط. قل الباحث لديه وظيفة صغيرة تقوم بشيء واحد بسيط (هنا خط واحد فقط للإيجاز). وفي هذا المثال سيزيد هذا العدد إلى القوة الخامسة:

```
def take_fifth_power(x):
  النتيجة = x * x * x * x * x * x * x
  نتيجة العودة
```

اختبار الوحدة لهذه الوظيفة يمكن أن يبدو هكذا:
```
def test_take_fifth_power():
  تأكيد take_fifth_power(1.5) == 7.59375
```

لذا فهو يتأكد من أن النتيجة الصحيحة يتم إخراجها لمدخل معين. إذا لم يكن الاختبار سوف يفشل. ويواصل الباحث عمله. في وسطها، يقررون ترتيب هذه الوظيفة، ضرب العدد خمس مرات مثل هذا هو نوع من التقشب. يغيرون نتيجة `= x * x * x * x * x * x * x * x` سطر إلى `النتيجة = x * 5`. في المرة القادمة التي يجرون فيها اختبارات الوحدة، سيفشل هذا الاختبار، لأنهم ارتكبوا خطأ. ربما كانوا بحاجة إلى قهوة، ربما أصابعهم، ربما أصابعهم، ربما قام مساعدهم بإطلاقهم في أذنهم بقنبلة عصبية وتشويههم، ولكن عندما كانوا يرتبون هذه الدالة، كان عليهم كتابة النتيجة `= x ** 5` *ليس* `النتيجة = x * 5`. الاختبار الفاشل سوف يضع علامة على الخطأ ويمكن تصحيحه بسرعة. وإذا حدث خطأ كهذا دون ملاحظة، فإن ذلك قد يؤدي إلى أخطاء خطيرة في عمل الباحث.

لذا فإن اختبار الوحدة يؤدي إلى شفرة أكثر موثوقية، ولكن هناك فوائد أخرى أيضاً. أولاً، إنه يجعل التنمية أسرع من خلال جعل العثور على الأخطاء أسهل. الاختبارات الواسعة النطاق التي تختبر أجزاء كبيرة من التعليمات البرمجية (رغم أنها لا تزال مفيدة) لها عيب هو أنه إذا فشلت فمن الصعب تحديد مصدر الخطأ. لأن وحدة الاختبارات حسب تعريفها تختبر قطع صغيرة من التعليمات البرمجية، إنها تساعد المطورين على العثور على سبب الخطأ بسرعة أكبر بكثير من الاختبارات ذات المستوى الأعلى أو التعليمات البرمجية بدون أي اختبارات على الإطلاق. كما أن اختبارات الوحدة تجعل إصلاح الأخطاء أسرع وأسهل لأنها تصيد الأخطاء في وقت مبكر بينما يقتصر التأثير على وحدات فردية صغيرة. إذا لم يتم اكتشاف الأخطاء في وقت مبكر عن طريق اختبارات الوحدة، قد يكون وقت طويل قبل اكتشافها، التأثير في العمل اللاحق الذي بني على الشفرة الخاطئة. وهذا يعني أن المزيد من التعليمات البرمجية معرضة للخطر وأن إصلاح الخطأ يستغرق وقتاً أطول بكثير.

الميزة الرئيسية الأخرى لاختبار الوحدة هي أنها تحفز الباحثين بقوة على كتابة شفرة نموذجية لأن التعليمات البرمجية النموذجية أسهل بكتابة اختبارات الوحدة لها. الكود البرمجي هو الكود البرمجي الذي يتم تقسيمه إلى أجزاء يمكن التحكم بها والتي ينجز كل منها مهام بسيطة. ويتحقق ذلك عادة بتقسيم المدونة إلى وظائف ومجموعات من الوظائف. وعلى النقيض من ذلك، فإن النص الذي هو مجرد سلسلة طويلة ومتواصلة من الخطوط التي تنتج نتيجة هو غير وحدة نمطية بدرجة كبيرة.

الكود البرمجي التكميلي أسهل بكثير من إعادة الاستخدام. على سبيل المثال إذا كان للباحث وظيفة فردية تقوم ببعض الأشياء المفيدة وفي مشروع مستقبلي فإنهم يحتاجون إلى القيام بذلك مرة أخرى ومن السهل نسخ الوظيفة أو استيرادها. وعلى النقيض من ذلك، إذا كانت التعليمات البرمجية التي تقوم بهذا الشيء المفيد مرتبطة مع الكثير من التعليمات البرمجية الأخرى في برنامج نصي طويل، فمن الأصعب بكثير فصلها لإعادة استخدامها.

## نصائح اختبار الوحدة

- ولدى العديد من أطر الاختبار أدوات موجهة خصيصا نحو كتابة وإدارة اختبارات الوحدة.
- عزل البيئة الإنمائية عن بيئة الاختبار.
- كتابة حالات اختبار مستقلة عن بعضها البعض. فعلى سبيل المثال، إذا استخدمت الوحدة ألف النتيجة التي وفرتها وحدة أخرى باء، يجب عليك اختبار الوحدة ألف مع اختبار [مزدوج](#Use_test_doubles_stubs_mocking_where_appropriate)بدلاً من الاتصال بالوحدة B. إذا لم تقم بهذا الاختبار، قد يكون بسبب خطأ في الوحدة ألف *أو* الوحدة باء، جعل الخطأ أكثر صعوبة لتعقبه.
- الهدف هو تغطية جميع المسارات من خلال الوحدة. قم بإيلاء اهتمام خاص لشروط الحلقة.
- بالإضافة إلى كتابة الحالات للتحقق من السلوك، كتابة الحالات لضمان أداء الشفرة. فعلى سبيل المثال، إذا كانت الدالة التي يفترض أن تضيف رقمين تستغرق عدة دقائق لتشغيلها، فمن المرجح أن تكون هناك مشكلة.
- إذا وجدت عيبا في التعليمات البرمجية الخاصة بك، قم بكتابة اختبار يعرضه. لما؟ أولا، ستتمكن فيما بعد من التقاط العيب إذا لم تقم بإصلاحه بشكل صحيح. ثانياً، مجموعة الاختبارات الخاصة بك الآن أكثر شمولاً. وثالثا، سيكون من الأرجح أنك كسول جدا لكتابة الاختبار بعد أن قمت بالفعل بإصلاح العيب. قل الكود له وظيفة بسيطة لتصنيف الناس إما كبالغين أو أطفال:

```
def adult_or_child(age):

  # إذا كان العمر أكبر أو يساوي 18 سنة يصنفهم كشخص بالغ
  إذا كان العمر >= 18:
    person_status = 'البالغ'

  # إذا لم يكن الشخص بالغا يصنفهم كطفل
  آخر:
    person_status = 'طفل'

  Reperson_status
```

وقول أن هذه التعليمات البرمجية تحتوي على اختبار وحدة كهذا:

```
def test_adult_or_child():

  # اختبار أن الشخص البالغ مصنف تصنيفاً صحيحاً كشخص بالغ
  تأكيد على أن الشخص البالغ (22) = 'البالغ'

  # اختبار أن الطفل مصنف تصنيفاً صحيحاً كطفل
  يؤكد أن الطفل بالغ - أو - طفل (5) = 'طفل'

  العودة
```

هناك مشكلة في هذه التعليمات البرمجية التي لم يتم اختبارها: إذا تم توفير سن سالب، فلسوء الحظ سوف يصنف الشخص كطفل على الرغم من أن الأعمار السلبية غير ممكنة. يجب أن يرمي الرمز إلى خطأ في هذه الحالة.

إذاً بمجرد إصلاح الخطأ:
```
def adult_or_child(age):

# التحقق من العمر صالح
إذا كان العمر < 0:
  رفع القيمة 'لا يمكن أن يكون عمر سلبي'

# إذا كان العمر أكبر أو يساوي 18 سنة يصنفهم كبالغ
إذا كان العمر >= 18:
  person_status = 'البالغ'

# إذا لم يكن الشخص بالغا يصنفهم كطفل
آخر:
  person_status = 'طفل'

Reperson_status
```

قم بالمضي قدما وكتابة اختبار للتأكد من أن التغييرات المستقبلية في التعليمات البرمجية لا يمكن أن تتسبب في حدوثها مرة أخرى:
```
def test_adult_or_child():

#اختبار أن الشخص البالغ مصنف تصنيفاً صحيحاً كشخص بالغ
تأكيد على أن الشخص البالغ (البالغ) (22) == 'البالغ'

# اختبار أن الطفل مصنف تصنيفاً صحيحاً كطفل
يؤكد على أن الطفل (adult_or_child5) = 'طفل'

# اختبار أن تقديم عمر غير صحيح يؤدي إلى خطأ
مع الاختبار. aises(ValueError):
    adult_or_child(-10)
```
