<a name="General_guidance_and_good_practice_for_testing"></a>

# 一般的なガイダンスとテストの良い練習

{ref}`の異なる種類がいくつかあります`<rr-testing-types-of-testing> それぞれに特有のベストプラクティスがあります それにもかかわらず、それらのすべてに適用されるいくつかの一般的なガイダンスがあります。

(rr-testing-write-tests)=
## テストを書く - 任意のテスト!

特に大きなコードベースを持っている場合は、テストを書くプロセスを開始するのは圧倒的なことがあります。 さらに、前述のように、テストの多くの種類があり、それらのすべてを実装することは、登ることが不可能な山のように見えることができます。 ですから、この章で最も重要なガイダンスは以下の通りです: **いくつかのテストを書く**. 何千行ものコードの中で小さなものをテストすることは、何千行ものコードの中でテストすることよりも、無限に優れています。 You may not be able to do everything, but doing *something* is valuable.

可能な限り改善する 新しいコードでテストを含めるように頑張ってください既に書かれているすべてのコードに対してテストを書くことは不可能です。

## テストの実行

この章の2番目に重要なアドバイス:テストを実行します。 美しい、完璧なテストスイートを持っていることは、めったに実行しない場合は役に立ちません。 テストラン間に長いギャップを残すと、テストが失敗したときに何が間違っていたかを追跡することがより困難になります。 多くのコードが変更されるでしょう また、テストが実行され、それらが失敗してから数週間または数ヶ月が経っている場合。 平均してどの結果が有効か分からないのは難しいか不可能です 虫の影響を受けるように捨てなければならないのです

可能な限りテストを自動化することをお勧めします。 各テストを個別に実行する必要がある場合は、その退屈な苦痛プロセスは無視される可能性があります。 これは、テストフレームワークを利用することによって行うことができます ([後述の](#use-a-testing-framework))。 [Jenkins](https://jenkins.io) はこのためのもう一つの良いツールです。 理想的には、定期的にテストを実行するように設定します。

継続的インテグレーション(継続的インテグレーション章で説明)をプロジェクトに設定することを検討してください。 コードを変更するたびにテストが自動的に実行されます。 継続的な統合ソフトウェアに応じてテストに失敗した場合に通知します

## テストを実行するのにどのくらい時間がかかるかを考えてみましょう

{ref}`rr-testing-unittest` のようないくつかのテストは、小さなコードのみをテストするため、通常は非常に高速です。 しかし、コード全体を最後から最後までテストする {ref}`rr-testing-systemtest` のような他の種類のテスト コードに応じて実行に時間がかかることがあります このように、作業の各ビットの後にテストスイート全体を実行することは妨げになる可能性があります。 その場合、頻繁にユニットテストなどの軽量化試験を実施し、長いテストは一日一回のみ行う方が良いと思います。 また、実行にかかる時間に関連して、各種のテストの数を調整することもできます。 多くの単体テスト(または高速な他のタイプのテスト)を持つべきですが、実行に時間がかかるテストははるかに少ないはずです。

## テストと実行方法を記録する

テストの実行方法を説明するドキュメントを提供することが重要です。 未来のプロジェクトに戻ってきてくれるなら あなたの作品を再現したいと願う人のために。 このドキュメントは次のような主題を扱う必要があります

- 必要なテストデータセットファイルなどの任意のリソース
- テストを実行するために必要な設定/設定の調整
- どのソフトウェア（ [フレームワークのテスト](#use-a-testing-framework)など）をインストールする必要があります。

理想的には、必要なリソースを設定して構成するスクリプトを提供します。

## 現実的なケースをテスト

あなたがテストケースをできるだけ現実的にします。 例えば 実際のデータとできるだけ同じようにテストを実行するダミーデータを持っている 実際のデータが多くの null 値で厄介な場合、テストデータセットもそうであるべきです。

## テストフレームワークの使用

テストの書き込みと実行を容易にするためのツールがあります。これらはテストフレームワークとして知られています。 あなたが好きなものを見つけて、それが提供する機能について学び、それらを利用してください。 一般的なテストフレームワーク(およびそれらが適用する言語)は次のとおりです。

- 非依存言語
  - CT、実行可能ファイルのテストランナー、bashスクリプトなど。 レガシーコードの硬化に最適です
- C++
  - キャッチする
  - CppTest
  - テスト
  - google-test
- C
  - すべての C++ フレームワーク
  - チェック
  - CUnit
```{note}
最新のC++とCは今でも互換性がありますが、完全ではなく、テストフレームワークを相互に使用することで常に機能するとは限りません。
```
- Python
  - pytest (推奨)
  - unittest には標準の Python ライブラリが付属しています
- R 単位テスト
  - テスト
  - tinytest
  - svUnit (SciViews GUI で動作します)
- Fortran 単位テスト:
  - funit
  - pfunit (MPIで動作)

## 良いコードカバレッジを持つことを目指してください

コードカバレッジとは、テストでどの程度コードが「カバーされるか」を示す指標です。 より正確には、テストが実施されたときにコードがどのくらい実行されるかを測定します。 例えば If you have an `if` statement but only test things where that if statementが「False」と評価する場合、ifブロック内のコードのどれも実行されません。 結果として、あなたのコードカバレッジは < 100%になります。 コードカバレッジにはコメントのようなドキュメントは含まれていないため、より多くのドキュメントを追加するとパーセンテージに影響はありません。

検討したように、テストはテストなしで改善されます。 それにもかかわらず、少なくとも可能な限り高いコードカバレッジを目指すことは良いことです。

ほとんどのプログラミング言語には、ツールが組み込まれているか、インポートできるか、またはテストフレームワークの一部として、コードカバレッジを自動的に測定できます。 コードカバレッジを測定するための [小さなボット](https://codecov.io/) もあります。

**Pitfall: 適切なカバレッジの錯覚。** 場合によっては、同じコードが複数の方法でテストされることがあり、おそらく必要があります。 例えば、カバレッジは、"健全性チェック"テストをその出力に適用するコードをすばやく増やすことができます。( {ref} も参照)<rr-testing-challenges-difficult-quatify>しかし、これはコードが間違った理由から広範囲に正しい答えを生み出しているリスクを妨げるものではありません。 一般的に、コヒーレントコードの大きな塊ではなく、小さいブロックを分離する最良のテストがあります。 個々の論理のステップを選びます 全体の実行中に特定のコードの塊に起こる可能性があることを考えることによって導かれるようにしてください。 個々の症例をテストすることができます 多くの場合、同じコードが複数回テストされることになります。これは良いことです。

## 適切な場合にテストダブル/スタブ/モックを使用

テストが失敗した場合は、できるだけ簡単に失敗の原因を追跡できるように構築する必要があります。 これは、不可避的にテストしたいコードの一部が他のものに依存する場合に問題になります。 例えば、Webと相互作用するコードの一部のテストが失敗した場合。 インターネット接続に問題があるため、コードにバグ *や* がある可能性があります。 同様に、オブジェクトを使用するコードの一部のテストが失敗した場合、テストされているコードにバグがあるためです。 またはオブジェクトに関する問題(それ自身の別々のテストによってテストされるべきです)。 可能な場合、これらの依存関係はテストから除去される必要があります。 これは、実際の依存関係の代わりにテスト交換(テストダブル)を使用することによって行うことができます。 テストダブルスは以下のように分類できます:

- ダミーオブジェクトは渡されますが、使用されることはありません。つまり、メソッドは呼び出されません。 このようなオブジェクトは、例えばメソッドのパラメータリストを埋めるために使用できます。
- 偽のオブジェクトは動作する実装を持っていますが、通常は簡略化されます。 たとえば、実際のデータベースではなく、メモリ内データベースを使用します。
- スタブは、テスト中にこのスタブのインスタンスを使用する目的を持つインターフェイスまたはクラスの部分的な実装です。 Stubsは通常、テスト用にプログラムされたもの以外のものには応答しません。 Stubsは通話に関する情報を記録することもできます。
- モックオブジェクトは、インターフェイスや特定のメソッド呼び出しの出力を定義するクラスのダミー実装です。 モックオブジェクトは、テスト中に特定の動作を実行するように構成されています。 通常、システムとの相互作用を記録し、テストはそれを検証することができます。

テストダブルスは、テストされる他のオブジェクトに渡すことができます。

モックオブジェクトを手動で作成することも、モックフレームワークを使用してこれらのクラスをシミュレートすることもできます。 モックフレームワークを使用すると、実行時にモックオブジェクトを作成し、その動作を定義することができます。 モックオブジェクトの古典的な例はデータプロバイダです。 本番環境では、実際のデータソースに接続する実装が使用されます。 しかし、モックオブジェクトをテストする場合は、データソースをシミュレートし、テスト条件が常に同じであることを保証します。
